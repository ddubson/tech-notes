# \[WIP\] Running Malware

Malware often invokes code that is shared across the system, namely DLLs

## Dynamic Link Libraries \(DLLs\)

DLLs are a way to use libraries to share code among multiple applications.

DLLs are executable files but do not run alone, but export functions that can be used by other apps.

Windows comes prepackaged with DLLs for most common functions so that helps reduce the size of malware payloads overall.

Malware authors use DLLs in 3 ways:

1. **Store malicious code**: malicious code stored in a DLL, rather than an exe. Malware sometimes uses DLLs to load itself into another process
2. **Using Windows DLLs**: contain the functionality needed to interact with the OS.
3. **Using Third-Party DLLs**: to interact with other programs. Imports from 3rd party DLLs indicate interaction with that program.

## DLL Structure

DLL files look almost exactly like .exe files. DLLs use the PE file format and only a single flag indicates that the file is a DLL and not an EXE.

DLLs often have more exports and generally fewer imports.

The main DLL function is **DllMain -** has no label and is not an export in the DLL but is specified in the PE header as the fileâ€™s entry point.

* the function is called to notify the DLL whenever a process loads or unloads the library, creates a new thread, or finishes an existing thread.
* Allows the DLL to manage any per-process or per-thread resources.
* DLLs do not have per-thread resources, and they ignore calls to DLLMain that are caused by thread activity.

### Creating a new Process

Function most commonly used is `CreateProcess` - call this function  to create a process to execute its malicious code, to bypass firewalls

May use create process to create a remote shell

May create a new process by storing one program inside another in the resource section. When it runs, it can write out the binary to a new file on disk, and execute it.

### Creating a new Thread

Before an OS switches between threads, it must save all relevant information about the thread in a structure called **thread context**

`CreateThread` function is used to create a thread.

* Function caller specifies the start address via `start()`
* Execution begins at the start address and continues until the function returns.

Malware uses `CreateThread` in a few ways:

* Load new malicious library into process.
* Can create two new threads for input/output on a socket to create a remote access connection

Two create thread calls close to each other is an indication of a potential set up with a C&C or other remote full-duplex connection.

### Creating a Service

Services are background applications

Services are usually run as SYSTEM or similar privileged account

Malware uses services to run as high privileged accounts and start on boot.

Key Functions:

* `OpenSCManager` - returns handle to service control manager. all code that interacts with services will initially call this function.
* `CreateService` - Adds a new service to service control manager, allows the caller to specify whether to start at boot or not.
* `StartService` - start service \(if set to be started manually\)

Windows supports a few different types of services. A common one is `WIN32-SHARE-PROCESS` \(replace hyphen with underscore\), stores the code for service in a DLL

Another type is `KERNEL_DRIVER` - load into kernel

Each service has a subkey in the registry in

```
HKLM\SYSTEM\CurrentControlSet\Services
```

### Microsoft Component Object Model \(COM\)

Microsoft COM is an interface standard for components to talk to each other in isolation \(API\).

For malware analysis, it is important to understand which code will run as a result of a COM function call.

COM works with any programming language, designed to be used by all programs.

COM is implemented in a client-server framework.

* Clients are programs making use of COM objects
* Servers are COM objects themselves

Each thread that uses COM must call at least once:

```
OleInitialize
```

or

```
CoInitializeEx
```

COM objects are accessed via their globally unique identifiers \(GUIDs\) known as class identifiers \(CLSIDs\) and interface identifiers \(IIDs\)

A common function used by malware is `Navigate` which allows malware to open IE and access a web address.

* `Navigate` is part of `IWebBrowser2` interface, which specifies a list of functions that must be implemented.

## Kernel vs. User Mode

Windows has 2 processor privelege levels:

* **kernel mode**
  * fewer security checks
  * invalid instructions in the kernel can result in a BSOD \('Blue Screen of Death'\)
  * can manipulate code running in user space
  * much harder to develop in and debug in \(OS crashes common\)
  * most AVs run in kernel mode so they can monitor user-mode processes.
  * Nearly all rootkits utilize code in the kernel.
* **user mode**
  * all code runs in user mode except OS and HW drivers
  * each process has its own memory, security permissions, and resources.
  * cannot access hardware directly.
  * restricted as to the CPU registers it has access to.
  * to change state in kernel, must rely on Windows API

![](/assets/run-mlw-2.png)

Presense of `SYSENTER` `SYSCALL` or `INT 0x2E` instruction in disassembly means call is being made to kernel.

Processes running in kernel share resources and mem addresses.

## Native API

Low-level interface for interacting with Windows -- rarely used by non-malicious programs.

Bypasses the Windows API.

Microsoft created a multi-step process to be able to call the native API:

![](/assets/run-mlw-1.png)

User apps are given access to APIs like `kernel32.dll` 

Using Native API to avoid AV detection:![](/assets/run-mlw-3.png)



